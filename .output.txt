diff --git a/story_mode/story_mode.py b/story_mode/story_mode.py
index 8c07514..2eef486 100644
--- a/story_mode/story_mode.py
+++ b/story_mode/story_mode.py
@@ -9,6 +9,10 @@ from utils.game_mechanics.events.event_interface import IEvent
 from utils.game_mechanics.events.random_event import RandomEvent as GameRandomEvent
 from .npc import BaseNPC, StudentNPC, FacultyNPC, NPCManager
 from .progress import DefaultStoryProgressManager
+from .consequences import DynamicConsequencesSystem
+from .powers import PowerEvolutionSystem
+from .seasonal_events import SeasonalEventSystem
+from .companions import CompanionSystem

 logger = logging.getLogger('tokugawa_bot')

@@ -118,6 +122,10 @@ class StoryMode:
         self.event_manager = DefaultEventManager()
         self.npc_manager = NPCManager()
         self.progress_manager = DefaultStoryProgressManager()
+        self.consequences_system = DynamicConsequencesSystem()
+        self.power_system = PowerEvolutionSystem()
+        self.seasonal_event_system = SeasonalEventSystem()
+        self.companion_system = CompanionSystem()

         # Load events and NPCs
         self._load_events()
@@ -207,6 +215,9 @@ class StoryMode:
         # Initialize story progress if needed
         player_data = self.progress_manager.initialize_story_progress(player_data)

+        # Initialize dynamic consequences system
+        player_data = self.consequences_system.initialize_player(player_data)
+
         # Get current chapter
         chapter_id = self.progress_manager.get_current_chapter(player_data)
         chapter = self.chapter_loader.load_chapter(chapter_id)
@@ -238,6 +249,21 @@ class StoryMode:
                 for event in available_events
             ]

+        # Check for pending moments of definition
+        pending_moments = self.consequences_system.get_pending_moments(result["player_data"])
+        if pending_moments:
+            result["pending_moments"] = pending_moments
+
+        # Check for available companions in the current chapter
+        available_companions = self.get_available_companions(result["player_data"], chapter_id)
+        if available_companions:
+            result["available_companions"] = available_companions
+
+        # Check for available seasonal events
+        available_seasonal_events = self.get_current_season_events(result["player_data"])
+        if available_seasonal_events:
+            result["available_seasonal_events"] = available_seasonal_events
+
         return result

     def process_choice(self, player_data: Dict[str, Any], choice_index: int) -> Dict[str, Any]:
@@ -262,10 +288,26 @@ class StoryMode:
         # Process the choice
         result = chapter.process_choice(player_data, choice_index)

-        # Record the choice
+        # Record the choice in the progress manager
         choice_key = f"choice_{choice_index}"
         self.progress_manager.record_choice(result["player_data"], chapter_id, choice_key, choice_index)

+        # Get choice metadata if available
+        choice_metadata = None
+        if "chapter_data" in result and "choices" in result["chapter_data"]:
+            choices = result["chapter_data"]["choices"]
+            if choices and len(choices) > choice_index:
+                choice_metadata = choices[choice_index].get("metadata", {})
+
+        # Record the choice in the consequences system
+        result["player_data"] = self.consequences_system.record_choice(
+            result["player_data"],
+            chapter_id,
+            choice_key,
+            choice_index,
+            choice_metadata
+        )
+
         # Check if the chapter is complete
         if "current_dialogue" not in result["chapter_data"] or result["chapter_data"]["current_dialogue"] is None:
             # Complete the chapter
@@ -322,6 +364,24 @@ class StoryMode:
                 for event in available_events
             ]

+        # Check for pending moments of definition
+        pending_moments = self.consequences_system.get_pending_moments(result["player_data"])
+        if pending_moments:
+            result["pending_moments"] = pending_moments
+            # Clear pending moments after adding them to the result
+            result["player_data"] = self.consequences_system.clear_pending_moments(result["player_data"])
+
+        # Check for available companions in the current chapter
+        chapter_id = self.progress_manager.get_current_chapter(result["player_data"])
+        available_companions = self.get_available_companions(result["player_data"], chapter_id)
+        if available_companions:
+            result["available_companions"] = available_companions
+
+        # Check for available seasonal events
+        available_seasonal_events = self.get_current_season_events(result["player_data"])
+        if available_seasonal_events:
+            result["available_seasonal_events"] = available_seasonal_events
+
         return result

     def trigger_event(self, player_data: Dict[str, Any], event_id: str) -> Dict[str, Any]:
@@ -335,6 +395,9 @@ class StoryMode:
         Returns:
             Dict containing updated player data and event result
         """
+        # Initialize dynamic consequences system if needed
+        player_data = self.consequences_system.initialize_player(player_data)
+
         # Trigger the event
         player_data = self.event_manager.trigger_event(event_id, player_data)

@@ -349,7 +412,16 @@ class StoryMode:
             logger.warning(f"Event not found: {event_id}")
             return {"player_data": player_data, "error": f"Event not found: {event_id}"}

-        return {
+        # Apply event effects to faction reputation if specified in event data
+        if hasattr(event, 'data') and 'faction_effects' in event.data:
+            faction_effects = event.data.get('faction_effects', {})
+            for faction_id, change in faction_effects.items():
+                player_data = self.update_faction_reputation(player_data, faction_id, change)
+                logger.info(f"Event {event_id} changed reputation with faction {faction_id} by {change}")
+
+        # Check for pending moments of definition
+        pending_moments = self.consequences_system.get_pending_moments(player_data)
+        result = {
             "player_data": player_data,
             "event_result": {
                 "id": event_id,
@@ -359,6 +431,24 @@ class StoryMode:
             }
         }

+        if pending_moments:
+            result["pending_moments"] = pending_moments
+            # Clear pending moments after adding them to the result
+            result["player_data"] = self.consequences_system.clear_pending_moments(result["player_data"])
+
+        # Check for available companions in the current chapter
+        chapter_id = self.progress_manager.get_current_chapter(result["player_data"])
+        available_companions = self.get_available_companions(result["player_data"], chapter_id)
+        if available_companions:
+            result["available_companions"] = available_companions
+
+        # Check for available seasonal events
+        available_seasonal_events = self.get_current_season_events(result["player_data"])
+        if available_seasonal_events:
+            result["available_seasonal_events"] = available_seasonal_events
+
+        return result
+
     def update_affinity(self, player_data: Dict[str, Any], npc_name: str, change: int) -> Dict[str, Any]:
         """
         Updates a player's affinity with an NPC.
@@ -406,6 +496,9 @@ class StoryMode:
         # Initialize story progress if needed
         player_data = self.progress_manager.initialize_story_progress(player_data)

+        # Initialize dynamic consequences system
+        player_data = self.consequences_system.initialize_player(player_data)
+
         story_progress = player_data.get("story_progress", {})

         # Get current chapter
@@ -457,6 +550,16 @@ class StoryMode:
         # Sort relationships by affinity
         relationships.sort(key=lambda x: x["affinity"], reverse=True)

+        # Get faction reputations
+        faction_reputations = self.get_all_faction_reputations(player_data)
+
+        # Get player powers
+        powers = story_progress.get("powers", {})
+        power_status = {}
+
+        for power_id in powers:
+            power_status[power_id] = self.get_power_status(player_data, power_id)
+
         return {
             "current_chapter": chapter_info,
             "completed_chapters": completed_chapters,
@@ -467,5 +570,386 @@ class StoryMode:
             },
             "discovered_secrets": discovered_secrets,
             "special_items": special_items,
-            "relationships": relationships
+            "relationships": relationships,
+            "faction_reputations": faction_reputations,
+            "powers": power_status
         }
+
+    def get_faction_reputation(self, player_data: Dict[str, Any], faction_id: str) -> int:
+        """
+        Gets a player's reputation with a faction.
+
+        Args:
+            player_data: Player data from the database
+            faction_id: ID of the faction
+
+        Returns:
+            Reputation value
+        """
+        return self.consequences_system.get_faction_reputation(player_data, faction_id)
+
+    def get_faction_reputation_level(self, player_data: Dict[str, Any], faction_id: str) -> str:
+        """
+        Gets a player's reputation level with a faction.
+
+        Args:
+            player_data: Player data from the database
+            faction_id: ID of the faction
+
+        Returns:
+            Reputation level as a string
+        """
+        return self.consequences_system.get_faction_reputation_level(player_data, faction_id)
+
+    def get_all_faction_reputations(self, player_data: Dict[str, Any]) -> Dict[str, Dict[str, Any]]:
+        """
+        Gets all faction reputations for a player.
+
+        Args:
+            player_data: Player data from the database
+
+        Returns:
+            Dictionary mapping faction IDs to reputation data
+        """
+        return self.consequences_system.get_all_faction_reputations(player_data)
+
+    def update_faction_reputation(self, player_data: Dict[str, Any], faction_id: str, change: int) -> Dict[str, Any]:
+        """
+        Updates a player's reputation with a faction.
+
+        Args:
+            player_data: Player data from the database
+            faction_id: ID of the faction
+            change: Amount to change reputation by
+
+        Returns:
+            Updated player data
+        """
+        return self.consequences_system.update_faction_reputation(player_data, faction_id, change)
+
+    def initialize_player_power(self, player_data: Dict[str, Any], power_id: str) -> Dict[str, Any]:
+        """
+        Initializes a player's power.
+
+        Args:
+            player_data: Player data from the database
+            power_id: ID of the power type
+
+        Returns:
+            Updated player data
+        """
+        return self.power_system.initialize_player_power(player_data, power_id)
+
+    def get_player_power(self, player_data: Dict[str, Any], power_id: str) -> Optional[Dict[str, Any]]:
+        """
+        Gets a player's power progress.
+
+        Args:
+            player_data: Player data from the database
+            power_id: ID of the power type
+
+        Returns:
+            Power progress data or None if not found
+        """
+        return self.power_system.get_player_power(player_data, power_id)
+
+    def get_power_status(self, player_data: Dict[str, Any], power_id: str) -> Dict[str, Any]:
+        """
+        Gets the status of a player's power.
+
+        Args:
+            player_data: Player data from the database
+            power_id: ID of the power type
+
+        Returns:
+            Dictionary containing power status information
+        """
+        return self.power_system.get_power_status(player_data, power_id)
+
+    def unlock_skill_node(self, player_data: Dict[str, Any], power_id: str, node_id: str) -> Dict[str, Any]:
+        """
+        Unlocks a skill node for a player.
+
+        Args:
+            player_data: Player data from the database
+            power_id: ID of the power type
+            node_id: ID of the skill node
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.power_system.unlock_skill_node(player_data, power_id, node_id)
+
+    def perform_awakening_ritual(self, player_data: Dict[str, Any], power_id: str, ritual_id: str) -> Dict[str, Any]:
+        """
+        Performs an awakening ritual for a player.
+
+        Args:
+            player_data: Player data from the database
+            power_id: ID of the power type
+            ritual_id: ID of the awakening ritual
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.power_system.perform_awakening_ritual(player_data, power_id, ritual_id)
+
+    def complete_power_challenge(self, player_data: Dict[str, Any], power_id: str, challenge_id: str) -> Dict[str, Any]:
+        """
+        Completes a power challenge for a player.
+
+        Args:
+            player_data: Player data from the database
+            power_id: ID of the power type
+            challenge_id: ID of the power challenge
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.power_system.complete_power_challenge(player_data, power_id, challenge_id)
+
+    def get_available_skill_nodes(self, player_data: Dict[str, Any], power_id: str) -> List[Dict[str, Any]]:
+        """
+        Gets skill nodes available for unlocking.
+
+        Args:
+            player_data: Player data from the database
+            power_id: ID of the power type
+
+        Returns:
+            List of available skill nodes
+        """
+        return self.power_system.get_available_skill_nodes(player_data, power_id)
+
+    def get_available_awakening_rituals(self, player_data: Dict[str, Any], power_id: str) -> List[Dict[str, Any]]:
+        """
+        Gets awakening rituals available for performing.
+
+        Args:
+            player_data: Player data from the database
+            power_id: ID of the power type
+
+        Returns:
+            List of available awakening rituals
+        """
+        return self.power_system.get_available_awakening_rituals(player_data, power_id)
+
+    def get_available_power_challenges(self, player_data: Dict[str, Any], power_id: str) -> List[Dict[str, Any]]:
+        """
+        Gets power challenges available for attempting.
+
+        Args:
+            player_data: Player data from the database
+            power_id: ID of the power type
+
+        Returns:
+            List of available power challenges
+        """
+        return self.power_system.get_available_power_challenges(player_data, power_id)
+
+    # Seasonal Event System methods
+    def get_current_season_events(self, player_data: Dict[str, Any]) -> Dict[str, List[Dict[str, Any]]]:
+        """
+        Gets events available in the current season for a player.
+
+        Args:
+            player_data: Player data
+
+        Returns:
+            Dictionary mapping event types to lists of available events
+        """
+        return self.seasonal_event_system.get_current_season_events(player_data)
+
+    def participate_in_seasonal_event(self, player_data: Dict[str, Any], event_id: str) -> Dict[str, Any]:
+        """
+        Allows a player to participate in a seasonal event.
+
+        Args:
+            player_data: Player data
+            event_id: ID of the seasonal event
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.seasonal_event_system.participate_in_seasonal_event(player_data, event_id)
+
+    def participate_in_mini_game(self, player_data: Dict[str, Any], festival_id: str, mini_game_id: str) -> Dict[str, Any]:
+        """
+        Allows a player to participate in a mini-game at an academy festival.
+
+        Args:
+            player_data: Player data
+            festival_id: ID of the academy festival
+            mini_game_id: ID of the mini-game
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.seasonal_event_system.participate_in_mini_game(player_data, festival_id, mini_game_id)
+
+    def attempt_festival_challenge(self, player_data: Dict[str, Any], festival_id: str, challenge_id: str) -> Dict[str, Any]:
+        """
+        Allows a player to attempt an exclusive challenge at an academy festival.
+
+        Args:
+            player_data: Player data
+            festival_id: ID of the academy festival
+            challenge_id: ID of the challenge
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.seasonal_event_system.attempt_festival_challenge(player_data, festival_id, challenge_id)
+
+    def get_seasonal_event_status(self, player_data: Dict[str, Any]) -> Dict[str, Any]:
+        """
+        Gets the status of a player's participation in seasonal events.
+
+        Args:
+            player_data: Player data
+
+        Returns:
+            Dictionary containing seasonal event status information
+        """
+        return self.seasonal_event_system.get_seasonal_event_status(player_data)
+
+    # Companion System methods
+    def get_available_companions(self, player_data: Dict[str, Any], chapter_id: str) -> List[Dict[str, Any]]:
+        """
+        Gets companions available for recruitment in the current chapter.
+
+        Args:
+            player_data: Player data
+            chapter_id: Current chapter ID
+
+        Returns:
+            List of available companions
+        """
+        return self.companion_system.get_available_companions(player_data, chapter_id)
+
+    def get_recruited_companions(self, player_data: Dict[str, Any]) -> List[Dict[str, Any]]:
+        """
+        Gets companions that have been recruited by the player.
+
+        Args:
+            player_data: Player data
+
+        Returns:
+            List of recruited companions
+        """
+        return self.companion_system.get_recruited_companions(player_data)
+
+    def get_active_companion(self, player_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
+        """
+        Gets the currently active companion.
+
+        Args:
+            player_data: Player data
+
+        Returns:
+            Active companion data or None if no active companion
+        """
+        return self.companion_system.get_active_companion(player_data)
+
+    def recruit_companion(self, player_data: Dict[str, Any], companion_id: str) -> Dict[str, Any]:
+        """
+        Recruits a companion.
+
+        Args:
+            player_data: Player data
+            companion_id: ID of the companion to recruit
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.companion_system.recruit_companion(player_data, companion_id)
+
+    def activate_companion(self, player_data: Dict[str, Any], companion_id: str) -> Dict[str, Any]:
+        """
+        Activates a companion.
+
+        Args:
+            player_data: Player data
+            companion_id: ID of the companion to activate
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.companion_system.activate_companion(player_data, companion_id)
+
+    def deactivate_companion(self, player_data: Dict[str, Any], companion_id: str) -> Dict[str, Any]:
+        """
+        Deactivates a companion.
+
+        Args:
+            player_data: Player data
+            companion_id: ID of the companion to deactivate
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.companion_system.deactivate_companion(player_data, companion_id)
+
+    def advance_companion_arc(self, player_data: Dict[str, Any], companion_id: str, progress_amount: int) -> Dict[str, Any]:
+        """
+        Advances a companion's story arc.
+
+        Args:
+            player_data: Player data
+            companion_id: ID of the companion
+            progress_amount: Amount to advance the arc progress
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.companion_system.advance_companion_arc(player_data, companion_id, progress_amount)
+
+    def complete_companion_mission(self, player_data: Dict[str, Any], companion_id: str, mission_id: str) -> Dict[str, Any]:
+        """
+        Completes a mission in a companion's story arc.
+
+        Args:
+            player_data: Player data
+            companion_id: ID of the companion
+            mission_id: ID of the mission to complete
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.companion_system.complete_companion_mission(player_data, companion_id, mission_id)
+
+    def perform_sync_ability(self, player_data: Dict[str, Any], companion_id: str, ability_id: str) -> Dict[str, Any]:
+        """
+        Performs a synchronization ability with a companion.
+
+        Args:
+            player_data: Player data
+            companion_id: ID of the companion
+            ability_id: ID of the sync ability to perform
+
+        Returns:
+            Updated player data and result information
+        """
+        return self.companion_system.perform_sync_ability(player_data, companion_id, ability_id)
+
+    def get_companion_status(self, player_data: Dict[str, Any], companion_id: str) -> Dict[str, Any]:
+        """
+        Gets detailed status information for a companion.
+
+        Args:
+            player_data: Player data
+            companion_id: ID of the companion
+
+        Returns:
+            Dictionary containing companion status information
+        """
+        return self.companion_system.get_companion_status(player_data, companion_id)
+
+    def get_all_power_types(self) -> Dict[str, Any]:
+        """
+        Gets all registered power types.
+
+        Returns:
+            Dictionary mapping power type IDs to PowerType instances
+        """
+        return self.power_system.get_all_power_types()
